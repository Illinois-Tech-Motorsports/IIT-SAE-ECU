# Log8

Logging protocol used by IIT Motorsports

- [Log8](#log8)
  - [Goals](#goals)
  - [Data streams](#data-streams)
  - [API](#api)
  - [Telemetry](#telemetry)
    - [Extensions](#extensions)
    - [Usage Example](#usage-example)
    - [Encoding](#encoding)
    - [CAN BUS](#can-bus)
    - [SDBC](#sdbc)
    - [Flow of data](#flow-of-data)
  - [Log](#log)
    - [Extensions](#extensions-1)
    - [Usage Example](#usage-example-1)
    - [Encoding](#encoding-1)
    - [CAN BUS](#can-bus-1)
    - [Flow of data](#flow-of-data-1)
  - [Debug I/O](#debug-io)
    - [Extensions](#extensions-2)
    - [Usage Example](#usage-example-2)
    - [Input](#input)
    - [Output](#output)
    - [Flow of data](#flow-of-data-2)

## Goals

- Better standardize how telemetry values are sent and decoded
- More static mapping, reduce the necessity to extract known information
- Separate telemetry from logging

## Data streams

The device should be capable of outputting three separate streams of data, where Telemetry and Log are also output on the CAN line as deemed appropriate.

- Telemetry
  - Raw encoded value data
  - Data is logged to .dat file
  - Uses TelemetryMap.json
  - Output to CAN line
- Log
  - Encoded string messages
  - information useful to logs
    - such as info, warn, error, and fatal messages
  - Data is logged to .log file
  - Uses LogMap.json
  - Output to CAN line
- Debug I/O
  - Direct un-logged ASCII stream of device information
  - Steam takes in input to debug calls
    - Such as outputting the mapping file

|             | Telemetry | Log | Debug I/O |
| ----------- | --------- | --- | --------- |
| Encoded     | ✔         | ✔   | ✖         |
| Mapping     | ✔         | ✔   | ✖         |
| Logged      | ✔         | ✔   | ✖         |
| CAN Bus     | ✔         | ✔   | ✖         |
| Serial Out  | ✔         | ✔   | ✔         |
| Serial In   | ✖         | ✖   | ✔         |
| M2M         | SDBC      | ✖   | ✖         |
| Live Decode | ~         | ✔   | ✖         |

## API

The general API for logging is as follows

`x` : The extension that should be used for logging  
`ID` : The ID of the owner for this message  
`msg` : The string message, or telemetryID  
`...` : Depending on the usage, not used, the value of the telemetry entry, the optional value for a log, or vargs for a debug print

``` C++
Log.x(ID, msg, ...);
```

The API should be threadsafe, muxing the call as appropriate to ensure no race conditions when saving logged values.

## Telemetry

Includes things such as measurements, systems states, information not immediately useful to a person.
Because, ultimately, we will have a set number of measurements that are taken, these mappings can be more static.
In other words, these don't change often.
Used for M2M communication.

Telemetry revolves around posting values to the SDBC library, where it handles the encoding, CAN messages, and some M2M communication.

### Extensions

`p` : Post a value

### Usage Example

``` C++
// Generated by SDBC
const int POST_EXAMPLE_TELEMETRY_VALUE = 0;
const int POST_STEERING_WHEEL = 1;

// User call to post a value
Log.p(ID, POST_STEERING_WHEEL, analogRead(5)); // Post
```

Posted values should call the [SDBC](#sdbc) library in the backend to both buffer and sync it as deemed appropriate.
Beyond this, Log8 should only concern itself with saving this updated value to be logged, encoding is taken care of by [SDBC](#sdbc).

Because calls must be threadsafe, internally, actual writing to a file only has to make pointer incrementation atomic to where data should be written, as encoded data is always the same size.

### Encoding

Encoding of the actual message follows [SDBC](#sdbc) encoding, where the telemetryID is the unique address used on the CAN line and the 8 bytes of data for the value can be split up into multiple data types.
The [SDBC](#sdbc) library should be given the correct function to call Log8 to store final encoded values to non-volatile storage.

### CAN BUS

Each value is mapped to 8 byte blocks where each block has it's own unique address. This is handled by the [SDBC](#sdbc) library

### SDBC

**S**implified **D**ata**B**ase **C**AN (SDBC) is a conceptual implementation of DBC, such as with [CANdb++](https://www.vector.com/int/en/products/products-a-z/software/candb/).

The main benefit of using this standard is the auto-generation of definitions that is specific to our system.

Because values on the SDBC do not change frequently, the mapping file, the `.sdbc` file, does not have to be updated frequently, i.e each time the codebase is compiled.

The `.sdbc` file is structured in a way that is only relevant to us but is reminiscent of typical DBC.

Exact syntax is defined in the SDBC `README.md`

<!-- TODO: Link SDBC library -->

### Flow of data

1. Manually (or automatically?) create mappings of known and wanted values, including, data type, format, etc.
2. Generate all defines/IDs in a header file that represent each value given the mapping
3. Given the appropriate ID, the underlying logic for telemetry is able to process a value based on it's type, format, etc.
4. Decoding uses that same mapping, being able to more easily format and represent a value.

## Log

Closer to an event log, pushing when something is happening on either ECU.
Should retain previous logging protocol, as it is not static, programmer should be able to log anywhere.

Should not be used for M2M

Logs are to be entirely handled by Log8

### Extensions

`i` : Log an info level message  
`w` : Log a warning level message  
`e` : Log an error level message  
`f` : Log a fatal level message

### Usage Example

``` C++

Log.i(ID, "epic!!1!", 45); // Info
Log.w(ID, "wooah", 22); // Warning
Log.e(ID, "AAAHH", var); // Error
Log.f(ID, "oof", -1); // Fatal

```

Messages **must** be string literals, these are picked up by a preprocessor to be mapped.
This string shall not be a reference to a variable, it must be directly on the function call.

The optional value is limited to 32 bits, where it is 0 by default. The value can be a reference to a variable.

Do **NOT**, for whatever reason, deviate from the format shown here (such as with a multiline function call) to prevent issues when parsing these calls.

### Encoding

Encoding of these messages use the previous standard of logging. 2 bytes for ownerID, 2 bytes for stringID, and 4 bytes for the optional value (zero by default).

### CAN BUS

Sending log messages over CAN will use a single unique address for each device, where messages are muxed based on the ownerID and stringID

### Flow of data

1. Log calls in source are tokenized by a preprocessor
2. IDs and string literals are mapped to 16 bit integers and replaced in source
3. At runtime, calls to a log extension are interpreted as a single 64bit integer and both saved to non-volatile storage and pushed to CAN using the appropriate address

## Debug I/O

Communication is over serial where this stream is not logged in anyway. Output should be minimal and **disabled if stream is not opened**.

### Extensions

`d` : Log a debug message

### Usage Example

``` C++
Log.d(ID, "Some message %d", 420); // Debug

Log.d(ID, 894); // Debug
```

### Input

For now, input is unrestricted, can take in whatever format as long as it can be interpreted.

### Output

Direct output over serial, printf like (no encoding necessary). ID still required.

Must acknowledge that the serial line has been opened.

Must acknowledge data that is received and whatever actions that were taken as a result.

### Flow of data

1. Debug acknowledges serial line is open
2. Data received by debug line is pushed to a parser for debug calls, data and actions acknowledged
3. Debug messages are printed to line directly
